function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _ = require("lodash");

var CONSTANTS = require("../util/Constants");

var debug = require("../util/Debug");

var FrameworkError = require("../util/FrameworkError");

var Invoker = require("./Invoker").Invoker;

var InvokerResponse = require("./Invoker").InvokerResponse;

var LoggingErrorHelper = require("../util/LoggingErrorHelper");

var sleep = require("../util/Util").sleep;

var Util = require("../util/Util");

var VirtualDevice = require("virtual-device-sdk").VirtualDevice;

var maxResponseWaitTime;
var waitInterval;

module.exports =
/*#__PURE__*/
function (_Invoker) {
  _inherits(VirtualDeviceInvoker, _Invoker);

  function VirtualDeviceInvoker(runner) {
    _classCallCheck(this, VirtualDeviceInvoker);

    return _possibleConstructorReturn(this, _getPrototypeOf(VirtualDeviceInvoker).call(this, runner));
  }

  _createClass(VirtualDeviceInvoker, [{
    key: "batchSupported",
    value: function batchSupported() {
      return true;
    }
  }, {
    key: "before",
    value: function before(testSuite) {
      var locale = testSuite.locale || undefined;
      var voiceId = testSuite.voiceId || undefined;
      var virtualDeviceToken = testSuite.virtualDeviceToken;
      var virtualDeviceAsyncMode = testSuite.asyncMode;
      this.asyncMode = virtualDeviceAsyncMode;
      var deviceLocation = testSuite.deviceLocation || {};
      var stt = testSuite.stt || undefined;
      var screenMode = testSuite.screenMode;
      var client = testSuite.client;
      var projectId = testSuite.projectId;
      var phoneNumber = testSuite.phoneNumber;
      var extraParameters = testSuite.extraParameters || {};
      extraParameters = Util.cleanObject(extraParameters);
      maxResponseWaitTime = testSuite.maxAsyncE2EResponseWaitTime;
      waitInterval = testSuite.asyncE2EWaitInterval;

      if (!virtualDeviceToken) {
        throw new FrameworkError("A valid virtualDeviceToken property must be defined either in the testing.json or the yml test file under the config element");
      }

      var lat = Util.cleanValue(deviceLocation.lat);
      var lng = Util.cleanValue(deviceLocation.lng);
      var configuration = {
        asyncMode: virtualDeviceAsyncMode,
        client,
        locale,
        locationLat: lat,
        locationLong: lng,
        phoneNumber,
        projectId,
        screenMode,
        stt,
        token: virtualDeviceToken,
        voiceID: voiceId
      };
      configuration = _.assign(extraParameters, configuration);
      debug("Virtual Device instance creation: ", configuration);
      this._virtualDevice = new VirtualDevice(configuration);

      if (!process.env.VIRTUAL_DEVICE_BASE_URL && testSuite.virtualDeviceBaseURL) {
        debug("Setting virtual device url: ", testSuite.virtualDeviceBaseURL);
        this._virtualDevice.baseURL = testSuite.virtualDeviceBaseURL;
      }

      var homophones = testSuite.homophones;

      if (homophones) {
        var keys = Object.keys(homophones);

        for (var key of keys) {
          this._virtualDevice.addHomophones(key, homophones[key]);
        }
      }
    }
  }, {
    key: "convertInteractionsToMessages",
    value: function convertInteractionsToMessages(interactions) {
      var messages = []; // Keep an array of the actual interactions sent, as some may be skipped

      var messageInteractions = [];

      for (var interaction of interactions) {
        var utterance = interaction.utterance; // if (!utterance) {
        //     continue;
        // }

        var message = {
          phrases: [],
          text: utterance
        };
        messageInteractions.push(interaction);

        if (interaction.assertions) {
          for (var assertion of interaction.assertions) {
            // If this is a check on the prompt or the transcript
            //  we add the expected value as a phrase - this helps with speech recognition
            if ((assertion.path === "prompt" || assertion.path === "transcript") && (assertion.operator === "==" || assertion.operator === "=~")) {
              // Need to check if this is an array - the prompt assertions can specify a collection of strings
              if (Array.isArray(assertion.value)) {
                var phrases = assertion.value.filter(value => value.indexOf("{") === -1);
                message.phrases = message.phrases.concat(phrases);
              } else {
                if (assertion.value.indexOf("{") === -1) {
                  message.phrases.push(assertion.value);
                }
              }
            }
          }
        }

        messages.push(message);
      }

      return {
        messageInteractions,
        messages
      };
    }
  }, {
    key: "invokeBatch",
    value: function () {
      var _invokeBatch = _asyncToGenerator(function* (interactions) {
        var {
          messages,
          messageInteractions
        } = this.convertInteractionsToMessages(interactions);
        var results = new Array(messages.length);
        var errorOnProcess = undefined;
        var enableDebug = true;

        if (messages.length > 0) {
          try {
            results = yield this._virtualDevice.batchMessage(messages, enableDebug);
          } catch (error) {
            var parsedError = this.parseError(error);

            if (parsedError && parsedError.results) {
              results = parsedError.results;
            } else {
              debug("Error: " + JSON.stringify(error));
              LoggingErrorHelper.error("bst-test", "Error using bst-test on Node: " + process.version);
              LoggingErrorHelper.error("bst-test", error.stack);
              results.fill({});
              errorOnProcess = this.getError(error);
            }
          }
        }

        var responses = [];

        for (var i = 0; i < results.length; i++) {
          var virtualDeviceResponse = new VirtualDeviceResponse(messageInteractions[i], results[i]);

          if (errorOnProcess || results[i].error) {
            virtualDeviceResponse.errorOnProcess = errorOnProcess || results[i].error.message;
            responses.push(virtualDeviceResponse);
            break;
          }

          responses.push(virtualDeviceResponse);
        }

        if (this._virtualDevice.waitForSessionToEnd) yield this._virtualDevice.waitForSessionToEnd();
        return responses;
      });

      function invokeBatch(_x) {
        return _invokeBatch.apply(this, arguments);
      }

      return invokeBatch;
    }()
  }, {
    key: "sequentialInvocation",
    value: function () {
      var _sequentialInvocation = _asyncToGenerator(function* (interaction) {
        if (!interaction.utterance) {
          return;
        }

        var {
          messages
        } = this.convertInteractionsToMessages([interaction]);
        var message = messages[0];
        var results = new Array(1);
        var errorOnProcess = undefined;

        try {
          results = yield this._virtualDevice.batchMessage([message], true);
        } catch (error) {
          var parsedError = this.parseError(error);

          if (parsedError && parsedError.results) {
            results = parsedError.results;
          } else {
            debug("Error: " + JSON.stringify(error));
            results.fill({});
            errorOnProcess = this.getError(error);
          }
        }

        var virtualDeviceResponse = new VirtualDeviceResponse(interaction, results[0]);

        if (errorOnProcess) {
          virtualDeviceResponse.errorOnProcess = errorOnProcess;
          return virtualDeviceResponse;
        }

        return virtualDeviceResponse;
      });

      function sequentialInvocation(_x2) {
        return _sequentialInvocation.apply(this, arguments);
      }

      return sequentialInvocation;
    }()
  }, {
    key: "batchAsyncInvocation",
    value: function () {
      var _batchAsyncInvocation = _asyncToGenerator(function* (interaction, interactions) {
        // if (!interaction.utterance) {
        //     return;
        // }
        var {
          messages,
          messageInteractions
        } = this.convertInteractionsToMessages(interactions);
        var asyncBatchResult;
        var errorOnProcess = undefined;
        var rawVirtualDeviceResponse;
        var totalTimeWaited = 0;
        var isCompleted = false;
        var maxResponseWaitTimePerInteraction = maxResponseWaitTime;
        var waitIntervalPerInteraction = waitInterval;

        if (interaction.hasPause) {
          var pause = interaction.pauseSeconds * 1000;
          maxResponseWaitTimePerInteraction += pause;
          waitIntervalPerInteraction = pause > waitInterval ? pause : waitInterval;
          debug("Updating maxResponseWaitTime and waitInterval: ", maxResponseWaitTimePerInteraction, waitIntervalPerInteraction);
        }

        try {
          var interactionIndex = messageInteractions.findIndex(messageInteraction => {
            return messageInteraction.lineNumber === interaction.lineNumber;
          }); // This is the first interaction, we send the whole list of interactions and get the conversation id

          if (interactionIndex === 0 || !this.currentConversation) {
            asyncBatchResult = yield this._virtualDevice.batchMessage(messages, true);
            this.currentConversation = asyncBatchResult.conversation_id;

            this._runner.emit("conversation_id", undefined, this.currentConversation, undefined);

            debug({
              "conversation_id": this.currentConversation
            });
          } // We query every 5 seconds to see if we got the current interaction results


          var isCurrentInteractionTimeoutExceed = false;

          do {
            // we query first before waiting because after the first interaction this ensure to get the responses
            // as soon as we can to the user, instead of adding 5 obligatory seconds every time if we got more than
            // one response in the same result
            var _virtualDeviceResponse = yield this._virtualDevice.getConversationResults(this.currentConversation);

            var processedInteractions = _virtualDeviceResponse.results;

            if (processedInteractions.length) {
              if (processedInteractions[interactionIndex]) {
                // We have reached the interaction that we have at the moment
                rawVirtualDeviceResponse = processedInteractions[interactionIndex];
              }

              isCompleted = processedInteractions.some(processedInteraction => {
                return processedInteraction.status === "COMPLETED";
              });
            }

            isCompleted = _virtualDeviceResponse.status === "COMPLETED";

            if (totalTimeWaited >= maxResponseWaitTimePerInteraction) {
              isCurrentInteractionTimeoutExceed = true;
            }

            if (!isCurrentInteractionTimeoutExceed && !rawVirtualDeviceResponse) {
              yield sleep(waitIntervalPerInteraction);
              totalTimeWaited += waitIntervalPerInteraction;
            }
          } while (!rawVirtualDeviceResponse && !isCurrentInteractionTimeoutExceed && !isCompleted);

          if (isCurrentInteractionTimeoutExceed && !rawVirtualDeviceResponse) {
            errorOnProcess = "Timeout exceeded while waiting for the interaction response";
          }
        } catch (error) {
          var parsedError = this.parseError(error);

          if (parsedError && parsedError.results) {
            rawVirtualDeviceResponse = parsedError.results;
          } else {
            debug("Error: " + JSON.stringify(error));
            LoggingErrorHelper.error("bst-test", "Error using bst-test on Node: " + process.version);
            LoggingErrorHelper.error("bst-test", error.stack);
            errorOnProcess = this.getError(error);
          }
        }

        var virtualDeviceResponse = new VirtualDeviceResponse(interaction, rawVirtualDeviceResponse);

        if (errorOnProcess) {
          virtualDeviceResponse.errorOnProcess = errorOnProcess;
          return virtualDeviceResponse;
        }

        return virtualDeviceResponse;
      });

      function batchAsyncInvocation(_x3, _x4) {
        return _batchAsyncInvocation.apply(this, arguments);
      }

      return batchAsyncInvocation;
    }()
  }, {
    key: "invoke",
    value: function () {
      var _invoke = _asyncToGenerator(function* (interaction, interactions) {
        if (this.asyncMode) {
          return this.batchAsyncInvocation(interaction, interactions);
        } else {
          return this.sequentialInvocation(interaction);
        }
      });

      function invoke(_x5, _x6) {
        return _invoke.apply(this, arguments);
      }

      return invoke;
    }()
  }, {
    key: "getError",
    value: function getError(error) {
      var objectError = undefined;

      try {
        objectError = JSON.parse(error);
      } catch (_e) {
        objectError = error;
      }

      if (typeof objectError === "string") {
        return objectError;
      } else if (typeof objectError === "object") {
        if (objectError.error) {
          if (typeof objectError.error === "string") {
            return objectError.error;
          } else if (Array.isArray(objectError.error)) {
            return objectError.error.join(", ");
          }
        } else if (objectError.message) {
          return objectError.message;
        }

        return "Error description missing.";
      }
    }
  }, {
    key: "parseError",
    value: function parseError(error) {
      try {
        return JSON.parse(error);
      } catch (error) {
        return undefined;
      }
    }
  }, {
    key: "stopProcess",
    value: function () {
      var _stopProcess = _asyncToGenerator(function* () {
        return yield this._virtualDevice.stopConversation(this.currentConversation);
      });

      function stopProcess() {
        return _stopProcess.apply(this, arguments);
      }

      return stopProcess;
    }()
  }, {
    key: "asyncMode",
    get: function () {
      return this._asyncMode;
    },
    set: function (asyncMode) {
      this._asyncMode = asyncMode;
    }
  }, {
    key: "currentConversation",
    get: function () {
      return this._currentConversation;
    },
    set: function (currentConversation) {
      this._currentConversation = currentConversation;
    }
  }]);

  return VirtualDeviceInvoker;
}(Invoker);

var VirtualDeviceResponse =
/*#__PURE__*/
function (_InvokerResponse) {
  _inherits(VirtualDeviceResponse, _InvokerResponse);

  function VirtualDeviceResponse(interaction, sourceJSON) {
    _classCallCheck(this, VirtualDeviceResponse);

    return _possibleConstructorReturn(this, _getPrototypeOf(VirtualDeviceResponse).call(this, interaction, sourceJSON));
  }

  _createClass(VirtualDeviceResponse, [{
    key: "cardContent",
    value: function cardContent() {
      return _.get(this.json, "card.textField");
    }
  }, {
    key: "cardImageURL",
    value: function cardImageURL() {
      return _.get(this.json, "card.imageURL");
    }
  }, {
    key: "cardTitle",
    value: function cardTitle() {
      return _.get(this.json, "card.mainTitle");
    }
  }, {
    key: "prompt",
    value: function prompt() {
      return _.get(this.json, "transcript");
    }
  }, {
    key: "reprompt",
    value: function reprompt() {
      return undefined;
    }
  }, {
    key: "sessionEnded",
    value: function sessionEnded() {
      return undefined;
    }
  }, {
    key: "supported",
    value: function supported(jsonPath) {
      var platform = _.get(this._interaction, "test.testSuite.platform");

      var ignorePropertiesRaw = _.get(this._interaction, "test.testSuite.ignoreProperties");

      var testType = _.get(ignorePropertiesRaw, `${platform}.type`);

      var ignoredProperties = [];

      if (testType == "e2e") {
        var paths = _.get(ignorePropertiesRaw, `${platform}.paths`);

        if (paths && paths.length) ignoredProperties = paths.split(",").map(x => x.trim());
      }

      if (platform === CONSTANTS.PLATFORM.google) {
        ignoredProperties.push("card.type");
        ignoredProperties.push("streamURL");
      }

      if (ignoredProperties.includes(jsonPath)) {
        return false;
      }

      return true;
    } // eslint-disable-next-line no-unused-vars

  }, {
    key: "ignoreCase",
    value: function ignoreCase(jsonPath) {
      return ["prompt", "transcript"].includes(jsonPath);
    }
  }]);

  return VirtualDeviceResponse;
}(InvokerResponse);