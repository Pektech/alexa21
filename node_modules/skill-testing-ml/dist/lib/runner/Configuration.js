function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var _ = require("lodash");

var CONSTANTS = require("../util/Constants");

var cosmiconfig = require("cosmiconfig");

var debug = require("../util/Debug");

var fs = require("fs");

var path = require("path");

var Util = require("../util/Util");

module.exports =
/*#__PURE__*/
function () {
  function Configuration() {
    _classCallCheck(this, Configuration);
  }

  _createClass(Configuration, [{
    key: "load",
    // Load configuration
    //  json: json configuration
    //  pathName: path were the test files are located  
    value: function () {
      var _load = _asyncToGenerator(function* (json, pathName, cliOverrides) {
        if (json) {
          this.configurationJSON = json;
        } else {
          var searchPlaces = ["./test/unit/testing.json", "./test/unit/skill-testing.json", "./test/e2e/testing.json", "./test/e2e/skill-testing.json", "./test/testing.json", "./test/skill-testing.json", "testing.json", "skill-testing.json"];

          if (pathName) {
            searchPlaces.unshift(`${pathName}/testing.json`);
            searchPlaces.unshift(`${pathName}/skill-testing.json`);
          } // Load the configuration file for skill-testing, if there is one


          var configExplorer = cosmiconfig("skill-testing", {
            searchPlaces
          });
          var skillConfigResult = yield configExplorer.search();
          this.configurationJSON = skillConfigResult ? skillConfigResult.config : {};
          this.configurationJSON.configurationPath = skillConfigResult && skillConfigResult.filepath;
        }

        var jestConfig = this.jestDefaults(); // Test coverage goes under ./test_output/coverage

        jestConfig.coverageDirectory = path.join(this.resultsDirectory(), "coverage"); // Override jest values

        var jestOverrides = this.configurationJSON.jest;

        if (jestOverrides) {
          for (var key of Object.keys(jestOverrides)) {
            debug("JEST - Override " + key + ": " + jestOverrides[key]);
            jestConfig[key] = jestOverrides[key];
          }
        }

        this.configurationJSON.jest = jestConfig;
        this.overrideConfigurationWithEnvVariables();
        this.overrideConfigurationWithCli(cliOverrides);

        if (!this.configurationJSON.jest.reporters || !this.configurationJSON.jest.reporters.length) {
          this.configurationJSON.jest.reporters = ["default"];
        }

        if (this.configurationJSON.jest.reporters.includes("default")) {
          if (!("html" in this.configurationJSON) || this.configurationJSON.html === true) {
            this.configurationJSON.jest.reporters.push(this.htmlReporterConfiguration());
          }
        }
      });

      function load(_x, _x2, _x3) {
        return _load.apply(this, arguments);
      }

      return load;
    }()
  }, {
    key: "configurationDir",
    value: function configurationDir() {
      return path.dirname(this.configurationJSON.configurationPath);
    }
  }, {
    key: "htmlReporterConfiguration",
    value: function htmlReporterConfiguration() {
      var pathToModule = path.join(__dirname, "../../node_modules/jest-stare"); // If we do not find jest-stare in this directory, means this module (skill-testing-ml) is a dependency
      // In that case, we keep going up to the node_modules that contains skill-testing-ml - jest-stare will be at that same level

      if (!fs.existsSync(pathToModule)) {
        pathToModule = path.join(__dirname, "../../../../jest-stare");
      }

      if (!this.json().type || this.json().type === CONSTANTS.TYPE.unit) {
        Configuration.setEnvIfUndefined("JEST_STARE_COVERAGE_LINK", "../coverage/lcov-report/index.html");
      } else {
        delete process.env.JEST_STARE_COVERAGE_LINK;
      }

      Configuration.setEnvIfUndefined("JEST_STARE_RESULT_DIR", path.join(this.resultsDirectory(), "report"));
      Configuration.setEnvIfUndefined("JEST_STARE_LOG", "false");
      return pathToModule;
    }
  }, {
    key: "jestPath",
    value: function jestPath() {
      var defaultJestPath = path.join(__dirname, "../node_modules/.bin/jest");
      return this.json().jestPath ? this.json().jestPath : defaultJestPath;
    }
  }, {
    key: "jestConfig",
    value: function jestConfig() {
      return this.json().jest;
    }
  }, {
    key: "json",
    value: function json() {
      return this.configurationJSON;
    }
  }, {
    key: "jestDefaults",
    value: function jestDefaults() {
      // Get the skill testing jest delegate - relative to this file
      var testRunnerPath = path.join(__dirname, "../runner/JestAdapter.js");
      debug("JestTestRunner: " + testRunnerPath); // Configuration is a combination of Jest elements and Skill Testing ones

      return {
        collectCoverage: true,
        collectCoverageFrom: ["**/*.js", "!**/node_modules/**", "!**/vendor/**", "!**/test_output/**"],
        coverageDirectory: "./coverage/",
        moduleFileExtensions: ["ts", "js", "json", "node", "yml"],
        silent: false,
        testEnvironment: "node",
        testMatch: ["**/test/*.yml", "**/tests/*.yml", "**/*.e2e.yml", "**/*.spec.yml", "**/*.test.yml"],
        testPathIgnorePatterns: ["/coverage/", "/locales/", "/lambda/", "/test_output/"],
        testRunner: testRunnerPath,
        testURL: "http://localhost/",
        verbose: true
      };
    }
  }, {
    key: "resultsDirectory",
    value: function resultsDirectory() {
      var testResultsDir = path.join(process.cwd(), "test_output");

      if (!fs.existsSync(testResultsDir)) {
        fs.mkdirSync(testResultsDir);
      }

      return testResultsDir;
    }
  }, {
    key: "skillTestingConfig",
    value: function skillTestingConfig() {
      return this.json();
    }
  }, {
    key: "value",
    value: function value(propertyName, overrides, defaultValue) {
      if (overrides && propertyName in overrides) {
        return Util.cleanValue(overrides[propertyName].valueOf());
      }

      if (propertyName in this.json()) {
        return Util.cleanValue(this.json()[propertyName]);
      }

      return defaultValue;
    }
  }, {
    key: "findReplaceMap",
    value: function findReplaceMap() {
      return this.value("findReplace", undefined, {});
    }
  }, {
    key: "overrideConfigurationWithEnvVariables",
    value: function overrideConfigurationWithEnvVariables() {
      for (var key of Object.keys(process.env)) {
        var value = _.get(this.configurationJSON, key);

        if (value) {
          _.set(this.configurationJSON, key, Util.cleanValue(process.env[key]));
        }
      }
    }
  }, {
    key: "overrideConfigurationWithCli",
    value: function overrideConfigurationWithCli(cliOverrides) {
      if (!cliOverrides) return;

      for (var key of Object.keys(cliOverrides)) {
        var newValue = cliOverrides[key];

        if (newValue !== undefined) {
          _.set(this.configurationJSON, key, Util.cleanValue(newValue));
        }
      }
    }
  }], [{
    key: "configure",
    value: function () {
      var _configure = _asyncToGenerator(function* (json, pathName, cliOverrides) {
        if (Configuration.singleton) {
          return;
        }

        Configuration.singleton = new Configuration();
        return yield this.singleton.load(json, pathName, cliOverrides);
      });

      function configure(_x4, _x5, _x6) {
        return _configure.apply(this, arguments);
      }

      return configure;
    }()
  }, {
    key: "setEnvIfUndefined",
    value: function setEnvIfUndefined(key, value) {
      if (!(key in process.env)) {
        process.env[key] = value;
      }
    }
  }, {
    key: "reset",
    value: function () {
      var _reset = _asyncToGenerator(function* () {
        Configuration.singleton = undefined;
      });

      function reset() {
        return _reset.apply(this, arguments);
      }

      return reset;
    }()
  }, {
    key: "instance",
    value: function instance() {
      return Configuration.singleton;
    }
  }]);

  return Configuration;
}();