function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var _ = require("lodash");

var chalk = require("chalk");

var Configuration = require("./Configuration");

var CONSTANTS = require("../util/Constants");

var FrameworkError = require("../util/FrameworkError");

var fs = require("fs");

var InteractionResult = require("../test/TestResult").InteractionResult;

var LoggingErrorHelper = require("../util/LoggingErrorHelper");

var SmapiError = require("../util/SmapiError");

var TestParser = require("../test/TestParser");

var TestResult = require("../test/TestResult").TestResult;

var Util = require("../util/Util");

module.exports =
/*#__PURE__*/
function () {
  function TestRunner(config) {
    _classCallCheck(this, TestRunner);

    this._config = config;
    this._subscribers = {
      message: [],
      result: []
    };
  }

  _createClass(TestRunner, [{
    key: "run",
    value: function () {
      var _run = _asyncToGenerator(function* (testFile, context) {
        var _this = this;

        return new Promise((resolve, reject) => {
          fs.readFile(testFile, "utf8",
          /*#__PURE__*/
          function () {
            var _ref = _asyncToGenerator(function* (error, data) {
              if (error) {
                reject(error);
              }

              try {
                // This may have already been called, but needs to be called again inside of the Jest runner
                yield Configuration.configure(_this._config);

                var testSuite = _this.parseContents(testFile, data);

                resolve((yield _this.runSuite(testSuite, context)));
              } catch (e) {
                LoggingErrorHelper.error("bst-test", "Error using bst-test on Node: " + process.version);
                LoggingErrorHelper.error("bst-test", e.stack);
                reject(e);
              }
            });

            return function (_x3, _x4) {
              return _ref.apply(this, arguments);
            };
          }());
        });
      });

      function run(_x, _x2) {
        return _run.apply(this, arguments);
      }

      return run;
    }()
  }, {
    key: "runSuite",
    value: function () {
      var _runSuite = _asyncToGenerator(function* (testSuite, context) {
        // This may have already been called, but needs to be called again inside of the Jest runner
        yield Configuration.configure(this._config);
        yield testSuite.loadLocalizedValues();
        var locales = testSuite.locales; // locales now include locales and locale, if property not present we throw the framework error

        if (locales) {
          var localesList = locales.split(",").map(l => l.trim());
          var results = [];

          for (var i = 0; i < localesList.length; i++) {
            results.push((yield this.runSuiteForLocale(testSuite, context, localesList[i])));
          }

          results = [].concat.apply([], results);
          return results;
        } else {
          throw new FrameworkError("Locale must be defined either in the testing.json or the test file itself under the config element");
        }
      });

      function runSuite(_x5, _x6) {
        return _runSuite.apply(this, arguments);
      }

      return runSuite;
    }()
  }, {
    key: "runSuiteForLocale",
    value: function () {
      var _runSuiteForLocale = _asyncToGenerator(function* (testSuite, context, locale) {
        if (!locale) {
          throw new FrameworkError("Locale must be defined either in the testing.json or the test file itself under the config element");
        }

        var testSuiteWithLocale = _.cloneDeep(testSuite);

        testSuiteWithLocale.currentLocale = locale;
        this.replaceLocalizedValues(testSuiteWithLocale);

        if (testSuiteWithLocale.filterObject() && testSuiteWithLocale.filterObject().onTestSuiteStart) {
          yield testSuiteWithLocale.filterObject().onTestSuiteStart(testSuiteWithLocale);
        }

        var invokerName = this.getInvoker(testSuite);

        var InvokerClass = require("./" + invokerName);

        var invoker = new InvokerClass(this);

        try {
          yield invoker.before(testSuiteWithLocale);
        } catch (error) {
          this.emit("result", error);
          throw error;
        }

        var batchEnabled = testSuiteWithLocale.batchEnabled;
        var asyncMode = testSuiteWithLocale.asyncMode;
        testSuiteWithLocale.processIncludedAndExcludedTags();
        testSuiteWithLocale.processOnlyFlag();
        var testResults = [];

        if (testSuite.hasDeprecatedOperators) {
          // eslint-disable-next-line no-console
          console.log(chalk.yellow("WARNING: == and =~ operators are no longer supported, use \":\" instead"));
        }

        if (testSuite.type !== "unit" && testSuite.hasDeprecatedE2EOperators) {
          // eslint-disable-next-line no-console
          console.log(chalk.yellow("WARNING: >, >=, < and <= are unit test operators only"));
        }

        for (var test of testSuiteWithLocale.tests) {
          if (testSuite.filterObject() && testSuite.filterObject().onTestStart) {
            yield testSuite.filterObject().onTestStart(test);
          }

          yield invoker.beforeTest(test);
          var testResult = new TestResult(test);
          testResult.locale = locale;
          testResults.push(testResult);

          if (test.skip) {
            yield invoker.afterTest(test); // if we skip we still need to do the after test in case is closing something like in VGA

            continue;
          }

          if (invoker.batchSupported() && batchEnabled && (test.hasGoto || test.hasExit)) {
            // eslint-disable-next-line no-console
            console.log(chalk.yellow("Warning: \"Goto\" and \"Exit\" functionality are only available when running in sequential mode, set \"batchEnabled\" property to false to enable it"));
          } // Process through the interactions
          // If there is a goto or this is not a batch invoker, run them one-by-one


          var results = void 0;

          if (!(invoker.batchSupported() && batchEnabled)) {
            results = yield this.sequentialRun(invoker, testSuiteWithLocale, test.interactions, context);
          } else {
            if (invoker.batchSupported() && asyncMode) {
              results = yield this.sequentialRun(invoker, testSuiteWithLocale, test.interactions, context);
            } else {
              results = yield this.batchRun(invoker, testSuiteWithLocale, test.interactions, context);
            }
          }

          testResult.interactionResults = results;
          yield invoker.afterTest(test);

          if (testSuite.filterObject() && testSuite.filterObject().onTestEnd) {
            yield testSuite.filterObject().onTestEnd(test, testResult);
          }
        }

        yield invoker.after(testSuiteWithLocale);

        if (testSuite.filterObject() && testSuite.filterObject().onTestSuiteEnd) {
          yield testSuite.filterObject().onTestSuiteEnd(testResults);
        }

        return testResults;
      });

      function runSuiteForLocale(_x7, _x8, _x9) {
        return _runSuiteForLocale.apply(this, arguments);
      }

      return runSuiteForLocale;
    }()
  }, {
    key: "resolveVariablesForAssertionInteraction",
    value: function () {
      var _resolveVariablesForAssertionInteraction = _asyncToGenerator(function* (testInteraction, resolveMethod) {
        if (!testInteraction.assertions || !testInteraction.assertions.length) {
          return;
        } // Using for without iterators to properly support async / await


        for (var i = 0; i < testInteraction.assertions.length; i++) {
          var assertion = testInteraction.assertions[i];

          if (!assertion.variables || !assertion.variables.length) {
            continue;
          }

          var _loop = function* (j) {
            var variable = assertion.variables[j];
            var variableValue = yield resolveMethod(variable, testInteraction); // Empty values are allowed but undefined means no replacement was found

            if (typeof variableValue == "undefined") {
              return {
                v: void 0
              };
            }

            if (Array.isArray(assertion.value)) {
              var replacedValues = assertion.value.map(val => {
                return val.split("{" + variable + "}").join(variableValue);
              });
              assertion._value = replacedValues;
            } else {
              assertion._value = assertion.value.split("{" + variable + "}").join(variableValue);
            }
          };

          for (var j = 0; j < assertion.variables.length; j++) {
            var _ret = yield* _loop(j);

            if (typeof _ret === "object") return _ret.v;
          }
        }
      });

      function resolveVariablesForAssertionInteraction(_x10, _x11) {
        return _resolveVariablesForAssertionInteraction.apply(this, arguments);
      }

      return resolveVariablesForAssertionInteraction;
    }()
  }, {
    key: "batchRun",
    value: function () {
      var _batchRun = _asyncToGenerator(function* (invoker, testSuite, interactions, context) {
        var startTime = new Date();
        var responses = yield invoker.invokeBatch(interactions);
        var endTime = new Date();
        var totalDuration = endTime - startTime;

        if (interactions.length) {
          var avgDuration = Math.floor(totalDuration / interactions.length);
          interactions.forEach(interaction => interaction.duration = avgDuration);
        } // we have variables to resolve, we need to resolve them after calling invocation


        if (testSuite.filterObject() && testSuite.filterObject().resolve) {
          for (var i = 0; i < interactions.length; i++) {
            var testInteraction = interactions[i];
            yield this.resolveVariablesForAssertionInteraction(testInteraction, testSuite.filterObject().resolve);
          }
        } // Add short-hand properties to each response


        responses.forEach(response => response.inject()); // Turn the responses into interaction results

        var interactionResults = responses.map(response => this.processResponse(response, testSuite, context));
        return interactionResults;
      });

      function batchRun(_x12, _x13, _x14, _x15) {
        return _batchRun.apply(this, arguments);
      }

      return batchRun;
    }()
  }, {
    key: "sequentialRun",
    value: function () {
      var _sequentialRun = _asyncToGenerator(function* (invoker, testSuite, interactions, context) {
        var goto;
        var results = [];
        var asyncMode = testSuite.asyncMode;

        for (var interaction of interactions) {
          // If we are in async mode we need to ignore any goto logic
          // If a goto is set, keep skipping until we match it
          if (!asyncMode && goto) {
            if (goto === interaction.utterance || goto == interaction.label) {
              goto = undefined;
            } else {
              continue;
            }
          }

          this.emit("message", undefined, interaction.toDTO(), context);
          var response = void 0;
          var startTime = new Date();

          try {
            response = yield invoker.invoke(interaction, interactions);
            var endTime = new Date();
            interaction.duration = endTime - startTime; // we have variables to resolve, we need to resolve them after calling invocation

            if (testSuite.filterObject() && testSuite.filterObject().resolve) {
              // we need to replace all interactions at once
              if (asyncMode) {
                for (var i = 0; i < interactions.length; i++) {
                  var testInteraction = interactions[i];
                  yield this.resolveVariablesForAssertionInteraction(testInteraction, testSuite.filterObject().resolve);
                }
              } else {
                yield this.resolveVariablesForAssertionInteraction(interaction, testSuite.filterObject().resolve);
              }
            }
          } catch (e) {
            if (!interaction.duration) {
              interaction.duration = new Date() - startTime;
            }

            var resultOnException = this.handleException(interaction, e);
            results.push(resultOnException);
            var interactionDto = interaction.toDTO();
            interactionDto.result = resultOnException.toDTO();
            this.emit("result", undefined, interactionDto, context); // smapi error will stop further interactions

            if (e instanceof SmapiError) {
              break;
            } else {
              continue;
            }
          } // Add short-hand properties to the response


          response.inject();
          var interactionResult = this.processResponse(response, testSuite, context); // If we are in async mode we need to ignore any goto logic

          if (!asyncMode && interactionResult.goto) {
            // If this result is a goto, set the goto label
            goto = interactionResult.goto;
          }

          results.push(interactionResult);

          if (!asyncMode && interactionResult.exited) {
            // If this is an exit, stop processing
            break;
          }

          if (testSuite.type === CONSTANTS.TYPE.e2e && response.errorOnProcess && interaction.assertions.length > 0) {
            break;
          }

          if (asyncMode && testSuite.stopTestOnFailure && (interactionResult.error || interactionResult.errors)) {
            invoker.stopProcess && (yield invoker.stopProcess());
            break;
          }
        }

        return results;
      });

      function sequentialRun(_x16, _x17, _x18, _x19) {
        return _sequentialRun.apply(this, arguments);
      }

      return sequentialRun;
    }()
  }, {
    key: "processResponse",
    value: function processResponse(response, testSuite, context) {
      var interaction = response.interaction; // We check if a filter object is defined
      // If so, it gives the test writer a chance to make changes to the response

      if (testSuite.filterObject() && testSuite.filterObject().onResponse) {
        testSuite.filterObject().onResponse(interaction.test, response.json);
      }

      var result = new InteractionResult(interaction);
      var isE2EFirstError = true;

      for (var assertion of interaction.assertions) {
        if (assertion.exit) {
          result = new InteractionResult(interaction, assertion);
          break;
        }

        if (!response.supported(assertion.path)) {
          continue;
        }

        var passed = assertion.evaluate(response);

        if (passed) {
          // If this is a goto, stop processing assertions here
          if (assertion.goto) {
            result = new InteractionResult(interaction, assertion);
            break;
          }
        } else if (!assertion.goto) {
          // If it did not pass, and was NOT a goto, then it is a failure
          // We do not consider tests that end in goto statements failures if they do not match
          var error = assertion.toString(response.json, response.errorOnProcess);

          if (testSuite.type === CONSTANTS.TYPE.e2e && !interaction.hasGoto && !interaction.hasExit && !response.errorOnProcess) {
            if (isE2EFirstError) {
              // We save first error data for backward compatibility
              result = new InteractionResult(interaction, assertion, error, response.errorOnProcess);
              isE2EFirstError = false;
            }

            result.addError(error);
          } else {
            result = new InteractionResult(interaction, assertion, error, response.errorOnProcess);
            break;
          }
        }
      }

      result.rawResponse = response.json;

      if (testSuite.trace) {
        // eslint-disable-next-line no-console
        console.log(chalk.cyan("Response Envelope:\n" + JSON.stringify(response.json, null, 2)));
      }

      var interactionDto = interaction.toDTO(response);
      interactionDto.result = result.toDTO();
      this.emit("result", undefined, interactionDto, context);
      return result;
    }
  }, {
    key: "parseContents",
    value: function parseContents(fileName, testContents) {
      var parser = new TestParser();
      parser.fileName = fileName;
      parser.load(testContents);
      return parser.parse();
    } // Method that can be used to print out the request payload, if available
    // TODO - should this be done with an event emitter instead?

  }, {
    key: "filterRequest",
    value: function filterRequest(interaction, request) {
      interaction.applyExpressions(request); // We check if a filter object is defined
      // If so, it gives the test writer a chance to make changes to the request

      var testSuite = interaction.test.testSuite;

      if (testSuite.filterObject() && testSuite.filterObject().onRequest) {
        testSuite.filterObject().onRequest(interaction.test, request);
      }

      if (testSuite.trace) {
        var test = interaction.test; // eslint-disable-next-line no-console

        console.log("File: " + testSuite.shortFileName + " Test: " + test.description + " Utterance: " + interaction.utterance); // eslint-disable-next-line no-console

        console.log(chalk.hex("#ff6633")("Request Envelope:\n" + JSON.stringify(request, null, 2)));
      }
    }
  }, {
    key: "handleException",
    value: function handleException(interaction, e) {
      var testSuite = interaction.test.testSuite;

      if (e.message && (e.message.startsWith("Unable to match utterance:") || e.message.startsWith("Interaction model has no intentName named"))) {
        var message = Util.errorMessageWithLine(e.message, testSuite.fileName, interaction.lineNumber);
        return new InteractionResult(interaction, undefined, message);
      } else {
        LoggingErrorHelper.error("bst-test", "Error using bst-test on Node: " + process.version);
        LoggingErrorHelper.error("bst-test", e.stack);

        if (e.type && e.type === "FrameworkError") {
          return new InteractionResult(interaction, undefined, e.message);
        } else if (e.message) {
          return new InteractionResult(interaction, undefined, e.message + "\n" + e.stack);
        } else {
          return new InteractionResult(interaction, undefined, e.toString());
        }
      }
    }
  }, {
    key: "subscribe",
    value: function subscribe(event, callback) {
      if (event in this._subscribers) {
        this._subscribers[event].push(callback);
      } else {
        this._subscribers[event] = [callback];
      }
    }
  }, {
    key: "unsubscribe",
    value: function unsubscribe(event) {
      this._subscribers[event] = [];
    }
  }, {
    key: "emit",
    value: function emit(event, error, data, context) {
      if (event in this._subscribers) {
        this._subscribers[event].forEach(subscriber => {
          subscriber(error, data, context);
        });
      }
    }
  }, {
    key: "getInvoker",
    value: function getInvoker(testSuite) {
      var invoker = testSuite.invoker;

      if (invoker) {
        return invoker;
      }

      var type = testSuite.type;
      var platform = testSuite.platform;

      if (type === CONSTANTS.TYPE.e2e) {
        return CONSTANTS.INVOKER.virtualDeviceInvoker;
      } else if (type === CONSTANTS.TYPE.simulation) {
        return CONSTANTS.INVOKER.SMAPIInvoker;
      } else if (type === CONSTANTS.TYPE.unit) {
        if (platform === CONSTANTS.PLATFORM.alexa) {
          return CONSTANTS.INVOKER.virtualAlexaInvoker;
        } else if (platform === CONSTANTS.PLATFORM.google) {
          return CONSTANTS.INVOKER.virtualGoogleAssistantInvoker;
        }
      }

      throw new FrameworkError("valid type and platform must be defined either in the testing.json or the test file itself under the config element");
    }
  }, {
    key: "replaceLocalizedValues",
    value: function replaceLocalizedValues(testSuite) {
      testSuite._description = testSuite.getLocalizedValue(testSuite.description) || testSuite.description;

      for (var test of testSuite.tests) {
        var localizedDescription = testSuite.getLocalizedValue(test.description) || test.description;
        test.description = localizedDescription;

        for (var interaction of test.interactions) {
          var localizedValue = interaction.utterance.split(" ").map(word => {
            return testSuite.getLocalizedValue(word) || word;
          }).join(" ");
          interaction.localizedUtterance = localizedValue;
        }
      }
    }
  }, {
    key: "configuration",
    get: function () {
      return this._config;
    }
  }]);

  return TestRunner;
}();